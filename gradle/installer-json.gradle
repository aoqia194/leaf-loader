import groovy.json.JsonOutput

tasks.register("generateInstallerJson", GenerateInstallerJsonTask) {
    configurations = [common: "installer", development: "development"]
    outputFile = file("src/main/resources/leaf-installer.json")
    options = [
        mainClass: [
            client: "dev.aoqia.leaf.loader.impl.launch.knot.KnotClient",
            server: "dev.aoqia.leaf.loader.impl.launch.knot.KnotServer"
        ]
    ]
}

abstract class GenerateInstallerJsonTask extends DefaultTask {
    @Input
    abstract MapProperty<String, String> getConfigurations()

    @Input
    abstract MapProperty<String, Object> getOptions()

    @OutputFile
    abstract RegularFileProperty getOutputFile()

    GenerateInstallerJsonTask() {
        outputs.upToDateWhen {
            false
        }
    }

    @TaskAction
    def run() {
        def json = [
            version: 2,
            min_java_version: 17,
            libraries: [
                client: [],
                common: [],
                server: [],
                development: [],
            ]
        ]

        configurations.get().each { side, name ->
            def resolvedArtifacts = getProject()
                .configurations
                .getByName(name)
                .resolvedConfiguration
                .resolvedArtifacts

            // Makes sure that no artifacts are duplicated.
            // Sometimes the same artifact is under 2 repositories.
            def processed = []

            for (final def artifact in resolvedArtifacts) {
                if (artifact.moduleVersion.toString() in processed) {
                    continue
                }

                final def id = artifact.moduleVersion.id

                // If it's a development dependency, add it to JiJ and go to next artifact.
                if (side == "development") {
                    json.libraries[side].add([
                        name: artifact.moduleVersion.toString(),
                        file: "loader://META-INF/jars/${id.name}-${id.version}.jar"
                    ])
                    processed.add(artifact.moduleVersion.toString())
                    continue
                }

                // Otherwise, we need to get the repository URL that the dep is located at.
                for (final var repo in getProject().repositories.asList()) {
                    if (artifact.moduleVersion.toString() in processed) {
                        continue
                    }

                    final def url = repo.properties.get('url')

                    try {
                        final String jarUrl = String.format("%s%s/%s/%s/%s-%s.jar",
                            url.toString(),
                            id.group.replace('.', '/'),
                            id.name,
                            id.version,
                            id.name,
                            id.version)

                        // Check if the repository is valid.
                        def jarFile = new URL(jarUrl).openStream()
                        def correctRepo = jarFile != null
                        jarFile.close()

                        if (correctRepo) {
                            def library = [
                                name: artifact.moduleVersion.toString(),
                                url: url.toString()
                            ]
                            library.putAll(resolveHashes(artifact.moduleVersion.toString()))
                            json.libraries[side].add(library)

                            // Add it to a processed list to prevent duplicates.
                            processed.add(artifact.moduleVersion.toString())
                        }
                    } catch (Exception ignored) {
                    }
                }
            }
        }

        json.putAll(options.get())
        getOutputFile().get().asFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
    }

    Map<String, Object> resolveHashes(String artifact) {
        return [
            md5: resolveHash(artifact, "md5", false),
            sha1: resolveHash(artifact, "sha1", true),
            sha256: resolveHash(artifact, "sha256", false),
            sha512: resolveHash(artifact, "sha512", false),
            size: resolveSize(artifact),
        ]
    }

    String resolveHash(String artifact, String hash, boolean required) {
        try {
            def config = project.configurations.detachedConfiguration(project
                .dependencies.create("${artifact}@jar.${hash}"))
            return config.singleFile.text
        } catch (ResolveException e) {
            def msg = hash + " hash was required but not found for artifact " + artifact
            if (required) {
                // e.printStackTrace()
                throw new RuntimeException(msg)
            }
        }

        return null
    }

    long resolveSize(String artifact) {
        def config = project.configurations.detachedConfiguration(
            project.dependencies.create("${artifact}@jar"))
        return config.singleFile.size()
    }
}
