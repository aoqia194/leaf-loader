import groovy.json.JsonOutput
import org.gradle.api.internal.artifacts.ivyservice.TypedResolveException

tasks.register("generateInstallerJson", GenerateInstallerJsonTask) {
    configurations = [common: "installer", development: "development"]
    outputFile = file("src/main/resources/leaf-installer.json")
    options = [
        mainClass: [
            client: "dev.aoqia.leaf.loader.impl.launch.knot.KnotClient",
            server: "dev.aoqia.leaf.loader.impl.launch.knot.KnotServer"
        ]
    ]
}

abstract class GenerateInstallerJsonTask extends DefaultTask {
    @Input
    abstract MapProperty<String, String> getConfigurations()

    @Input
    abstract MapProperty<String, Object> getOptions()

    @OutputFile
    abstract RegularFileProperty getOutputFile()

    GenerateInstallerJsonTask() {
        outputs.upToDateWhen {
            false
        }
    }

    @TaskAction
    def run() {

        def json = [
            version: 2,
            min_java_version: 17,
            libraries: [
                client: [],
                common: [],
                server: [],
                development: [],
            ]
        ]

        configurations.get().each { side, name ->
            Set<ResolvedArtifact> resolvedArtifacts = getProject()
                .configurations
                .getByName(name)
                .resolvedConfiguration
                .resolvedArtifacts

            def processed = []
            for (final ArtifactRepository repo in getProject().repositories.asList()) {
                for (final ResolvedArtifact artifact in resolvedArtifacts) {
                    if (artifact.moduleVersion.toString() in processed) {
                        continue
                    }

                    // Parse the url from the ArtifactRepository.
                    final def id = artifact.moduleVersion.id
                    final def url = repo.properties.get('url')
                    final String jarUrl = String.format("%s%s/%s/%s/%s-%s.jar",
                        url.toString(),
                        id.group.replace('.', '/'),
                        id.name,
                        id.version,
                        id.name,
                        id.version)

                    if (side == 'development' && artifact.file.toString().startsWith(
                        getProject().getRootProject().getProjectDir().toString())) {
                        json.libraries[side].add([
                            name: artifact.moduleVersion.toString(),
                            file: "loader://META-INF/jars/${id.name}-${id.version}.jar"
                        ])
                        processed.add(artifact.moduleVersion.toString())
                    } else {
                        try {
                            // Check if the repository is valid.
                            def jarFile = new URL(jarUrl).openStream()
                            def correctRepo = jarFile != null
                            jarFile.close()

                            if (correctRepo) {
                                def library = [
                                    name: artifact.moduleVersion.toString(),
                                    url: url.toString()
                                ]
                                library.putAll(resolveHashes(artifact.moduleVersion.toString()))
                                json.libraries[side].add(library)

                                // Add it to a processed list to prevent duplicates.
                                processed.add(artifact.moduleVersion.toString())
                            }
                        } catch (Exception ignored) {
                        }
                    }
                }
            }
        }

        json.putAll(options.get())
        getOutputFile().get().asFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
    }

    Map<String, Object> resolveHashes(String artifact) {
        return [
            md5: resolveHash(artifact, "md5", false),
            sha1: resolveHash(artifact, "sha1", true),
            sha256: resolveHash(artifact, "sha256", false),
            sha512: resolveHash(artifact, "sha512", false),
            size: resolveSize(artifact),
        ] as Map<String, Object>
    }

    String resolveHash(String artifact, String hash, boolean required) {
        try {
            def config = project.configurations.detachedConfiguration(project.dependencies
                .create("${artifact}@jar.${hash}"))
            return config.singleFile.text
        } catch (TypedResolveException e) {
            def msg = hash + " hash was required but not found for artifact " + artifact
            if (required) {
                e.printStackTrace()
                throw new RuntimeException(msg)
            }
        }
    }

    long resolveSize(String artifact) {
        def config = project.configurations.detachedConfiguration(project.dependencies
            .create("${artifact}@jar"))
        return config.singleFile.size()
    }
}
